---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# dirigible

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
<!-- badges: end -->

GDAL headers for R. (A fresh attempt at vapour with a firmer re-use basis). 

The underlying `gdalheaders` namespace is now feature complete with the C++ level of the [vapour package](https://CRAN.r-project.org/package=vapour). The main thing to do is establish this namespace
as a headers-only package, then migrate vapour over to use that. To do that we need Windows and MacOS support, 
which includes making sure the rwinlib tools/ stuff works and that the metadata files are set up correctly on
package load, and cleaned up with unload. 

## Installation

TBD but don't do it this will break your system 

## Example

Linux only for now.  


```{r example, eval=TRUE, include=TRUE}
library(dirigible)
f <- system.file("extdata/tab/list_locality_postcode_meander_valley.tab", package = "vapour")

## name of driver in use
dirigible:::driver_gdal_cpp(f)

## layer feature count
dirigible:::feature_count_gdal_cpp(f, layer = 0, sql = "", ex = 0)

## vector layer names
dirigible:::layer_names_gdal_cpp(f)

## report fields
dirigible:::report_fields_gdal_cpp(f, 0, sql = "")

## report fields
dirigible:::report_fields_gdal_cpp(f, 0, 
                sql = "SELECT FID, NAME FROM list_locality_postcode_meander_valley")


## read fields
as.data.frame(dirigible:::read_fields_gdal_cpp(f, layer = 0, sql = "", limit_n = 1, skip_n = 0, ex = 0, fid_column_name = character(0)))
 
## VSI list
u <- "/vsizip//vsicurl/http://dapds00.nci.org.au/thredds/fileServer/rr2/national_geophysical_compilations/http/radmap_v3_2015_filtered_dose/radmap_v3_2015_filtered_dose.ers.zip"
(paths <- dirigible:::vsi_list_gdal_cpp(u))

## sds
sdsfile <- system.file("extdata/gdal/sds.nc", package = "vapour", mustWork = TRUE)
dirigible:::sds_list_gdal_cpp(sdsfile)


## read names
unlist(dirigible:::read_names_gdal_cpp(f, 
                            layer = 0, sql = "", 
                            limit_n = 10, 
                            skip_n = 0, ex = 0))
osm <- system.file("extdata/osm/osm-ways.osm", package = "vapour", mustWork = TRUE)
unlist(dirigible:::read_names_gdal_cpp(osm, 
                            layer = 1,   ## layer 1 is 'lines'
                            sql = "", 
                            limit_n = 0, 
                            skip_n = 0, ex = 0))

## read proj info
names(dirigible:::projection_info_gdal_cpp(f, layer = 0, sql = ""))

## read gcp
gcpfile <- system.file("extdata/gcps/volcano_gcp.tif", package = "vapour", mustWork = TRUE)
dirigible:::raster_gcp_gdal_cpp(gcpfile)

## raster info
dirigible:::raster_info_gdal_cpp(gcpfile, FALSE)
dirigible:::raster_info_gdal_cpp(gcpfile, TRUE)$minmax

## an error, but ok
try(dirigible:::raster_info_gdal_cpp(sdsfile, FALSE))

## read raster
sstif <- system.file("extdata", "sst.tif", package = "vapour")
## a 5*5 window from a 10*10 region
dirigible:::raster_io_gdal_cpp(sstif, window = c(0, 0, 10, 10, 5, 5), band = 1, resample = "nearestneighbour")
dirigible:::raster_io_gdal_cpp(sstif, window = c(0, 0, 10, 10, 5, 5), band = 1,  resample = "lanczos")

## name of driver in use
dirigible:::driver_gdal_cpp(sstif)

# read geometry
str(dirigible:::read_geometry_gdal_cpp(f, layer = 0, sql = "",
                         what = "geometry",
                         textformat = "json",
                         limit_n = 1, skip_n = 0, ex = 0))

str(dirigible:::read_geometry_gdal_cpp(f, layer = 0, sql = "",
                         what = "text",
                         textformat = "json",
                         limit_n = 1, skip_n = 0, ex = 0))

str(dirigible:::read_geometry_gdal_cpp(f, layer = 0, sql = "",
                         what = "text",
                         textformat = "wkt",
                         limit_n = 1, skip_n = 0, ex = 0))

str(dirigible:::read_geometry_gdal_cpp(f, layer = 0, sql = "",
                         what = "text",
                         textformat = "gml",
                         limit_n = 1, skip_n = 0, ex = 0))

## got to be longlat for kml (just fwiw)
f1 <- system.file("gpkg/nc.gpkg", package = "sf")

str(dirigible:::read_geometry_gdal_cpp(f1, layer = 0, sql = "",
                         what = "text",
                         textformat = "kml",
                         limit_n = 1, skip_n = 0, ex = 0))

## sys
dirigible:::version_gdal_cpp()
str(dirigible:::drivers_list_gdal_cpp())

dirigible:::proj_to_wkt_gdal_cpp("+proj=laea +datum=WGS84")

## white zone
dirigible:::dirigible_unload_gdal()
try(dirigible:::layer_names_gdal_cpp(f))
dirigible:::dirigible_load_gdal()
dirigible:::layer_names_gdal_cpp(f)

```



### Warping in memory

Very WIP, needs a lot of thought around UX. 

```{r warper}
tas_wkt <- "PROJCRS[\"unknown\",\n    BASEGEOGCRS[\"unknown\",\n        DATUM[\"World Geodetic System 1984\",\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ID[\"EPSG\",6326]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8901]]],\n    CONVERSION[\"unknown\",\n        METHOD[\"Lambert Azimuthal Equal Area\",\n            ID[\"EPSG\",9820]],\n        PARAMETER[\"Latitude of natural origin\",-42,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",147,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"False easting\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1,\n                ID[\"EPSG\",9001]]]]"
prj <- "+proj=laea +lon_0=147 +lat_0=-42 +datum=WGS84"


f <- 1/10
dm <- as.integer(c(186, 298) * f)
gt <- c(-637239.4, 5030.0/f, 0.0, 261208.7, 0.0, -7760.0/f)

gt_dim_2ex <- function(x, dim) {
  xx <- c(x[1], x[1] + dim[1] * x[2]) - x[2]/2
  yy <- c(x[4] + dim[2] * x[6], x[4]) - x[6]/2
  raster::extent(c(xx, yy))
}

ex <- gt_dim_2ex(gt, dm)
f <- system.file("extdata", "sst.tif", package = "vapour")
vals <- dirigible:::warp_in_memory_gdal_cpp(f,source_WKT = "", 
                                            target_WKT = tas_wkt,
                                            target_geotransform = gt,
                             target_dim = dm, band = 1)

v <- vals[[1]]
v[v < 250] <- NA
library(raster)
data("wrld_simpl", package = "maptools")
plot(setValues(raster(ex, nrows = dm[2], ncols = dm[1]), v))
plot(spTransform(subset(wrld_simpl, NAME == "Australia"), prj), add = TRUE)
```


---

## Code of Conduct
  
Please note that the dirigible project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/0/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.
